{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useState, useMemo } from 'react';\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport { isInViewPort } from \"../util\";\nexport default function useTarget(target, open, gap) {\n  // ========================= Target =========================\n  // We trade `undefined` as not get target by function yet.\n  // `null` as empty target.\n  var _useState = useState(undefined),\n      _useState2 = _slicedToArray(_useState, 2),\n      targetElement = _useState2[0],\n      setTargetElement = _useState2[1];\n\n  useLayoutEffect(function () {\n    var nextElement = typeof target === 'function' ? target() : target;\n    setTargetElement(nextElement || null);\n  }); // ========================= Align ==========================\n\n  var _useState3 = useState(null),\n      _useState4 = _slicedToArray(_useState3, 2),\n      posInfo = _useState4[0],\n      setPosInfo = _useState4[1];\n\n  useLayoutEffect(function () {\n    if (targetElement) {\n      // Exist target element. We should scroll and get target position\n      if (!isInViewPort(targetElement)) {\n        targetElement.scrollIntoView(true);\n      }\n\n      var _targetElement$getBou = targetElement.getBoundingClientRect(),\n          left = _targetElement$getBou.left,\n          top = _targetElement$getBou.top,\n          width = _targetElement$getBou.width,\n          height = _targetElement$getBou.height;\n\n      var nextPosInfo = {\n        left: left,\n        top: top,\n        width: width,\n        height: height,\n        radius: 0\n      };\n      setPosInfo(function (origin) {\n        if (JSON.stringify(origin) !== JSON.stringify(nextPosInfo)) {\n          return nextPosInfo;\n        }\n\n        return origin;\n      });\n    } else {\n      // Not exist target which means we just show in center\n      setPosInfo(null);\n    }\n  }, [targetElement, open]); // ======================== PosInfo =========================\n\n  var mergedPosInfo = useMemo(function () {\n    if (!posInfo) {\n      return posInfo;\n    }\n\n    var gapOffset = (gap === null || gap === void 0 ? void 0 : gap.offset) || 6;\n    var gapRadius = (gap === null || gap === void 0 ? void 0 : gap.radius) || 2;\n    return {\n      left: posInfo.left - gapOffset,\n      top: posInfo.top - gapOffset,\n      width: posInfo.width + gapOffset * 2,\n      height: posInfo.height + gapOffset * 2,\n      radius: gapRadius\n    };\n  }, [posInfo, gap]);\n  return [mergedPosInfo, targetElement];\n}","map":{"version":3,"sources":["E:/railway/expressjs-mongoose/frontend/node_modules/@rc-component/tour/es/hooks/useTarget.js"],"names":["_slicedToArray","useState","useMemo","useLayoutEffect","isInViewPort","useTarget","target","open","gap","_useState","undefined","_useState2","targetElement","setTargetElement","nextElement","_useState3","_useState4","posInfo","setPosInfo","scrollIntoView","_targetElement$getBou","getBoundingClientRect","left","top","width","height","nextPosInfo","radius","origin","JSON","stringify","mergedPosInfo","gapOffset","offset","gapRadius"],"mappings":"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","sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useState, useMemo } from 'react';\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport { isInViewPort } from \"../util\";\nexport default function useTarget(target, open, gap) {\n  // ========================= Target =========================\n  // We trade `undefined` as not get target by function yet.\n  // `null` as empty target.\n  var _useState = useState(undefined),\n      _useState2 = _slicedToArray(_useState, 2),\n      targetElement = _useState2[0],\n      setTargetElement = _useState2[1];\n\n  useLayoutEffect(function () {\n    var nextElement = typeof target === 'function' ? target() : target;\n    setTargetElement(nextElement || null);\n  }); // ========================= Align ==========================\n\n  var _useState3 = useState(null),\n      _useState4 = _slicedToArray(_useState3, 2),\n      posInfo = _useState4[0],\n      setPosInfo = _useState4[1];\n\n  useLayoutEffect(function () {\n    if (targetElement) {\n      // Exist target element. We should scroll and get target position\n      if (!isInViewPort(targetElement)) {\n        targetElement.scrollIntoView(true);\n      }\n\n      var _targetElement$getBou = targetElement.getBoundingClientRect(),\n          left = _targetElement$getBou.left,\n          top = _targetElement$getBou.top,\n          width = _targetElement$getBou.width,\n          height = _targetElement$getBou.height;\n\n      var nextPosInfo = {\n        left: left,\n        top: top,\n        width: width,\n        height: height,\n        radius: 0\n      };\n      setPosInfo(function (origin) {\n        if (JSON.stringify(origin) !== JSON.stringify(nextPosInfo)) {\n          return nextPosInfo;\n        }\n\n        return origin;\n      });\n    } else {\n      // Not exist target which means we just show in center\n      setPosInfo(null);\n    }\n  }, [targetElement, open]); // ======================== PosInfo =========================\n\n  var mergedPosInfo = useMemo(function () {\n    if (!posInfo) {\n      return posInfo;\n    }\n\n    var gapOffset = (gap === null || gap === void 0 ? void 0 : gap.offset) || 6;\n    var gapRadius = (gap === null || gap === void 0 ? void 0 : gap.radius) || 2;\n    return {\n      left: posInfo.left - gapOffset,\n      top: posInfo.top - gapOffset,\n      width: posInfo.width + gapOffset * 2,\n      height: posInfo.height + gapOffset * 2,\n      radius: gapRadius\n    };\n  }, [posInfo, gap]);\n  return [mergedPosInfo, targetElement];\n}"]},"metadata":{},"sourceType":"module"}